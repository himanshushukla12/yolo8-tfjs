{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env, util } from '@tensorflow/tfjs-core';\nimport { getWebGLContext } from './canvas_util';\nimport { getTextureConfig } from './tex_util';\nexport function callAndCheck(gl, func) {\n  const returnValue = func();\n  if (env().getBool('DEBUG')) {\n    checkWebGLError(gl);\n  }\n  return returnValue;\n}\nfunction checkWebGLError(gl) {\n  const error = gl.getError();\n  if (error !== gl.NO_ERROR) {\n    throw new Error('WebGL Error: ' + getWebGLErrorMessage(gl, error));\n  }\n}\n// https://en.wikipedia.org/wiki/Half-precision_floating-point_format\nconst MIN_FLOAT16 = 5.96e-8;\nconst MAX_FLOAT16 = 65504;\nexport function canBeRepresented(num) {\n  if (env().getBool('WEBGL_RENDER_FLOAT32_ENABLED') || num === 0 || MIN_FLOAT16 < Math.abs(num) && Math.abs(num) < MAX_FLOAT16) {\n    return true;\n  }\n  return false;\n}\nexport function getWebGLErrorMessage(gl, status) {\n  switch (status) {\n    case gl.NO_ERROR:\n      return 'NO_ERROR';\n    case gl.INVALID_ENUM:\n      return 'INVALID_ENUM';\n    case gl.INVALID_VALUE:\n      return 'INVALID_VALUE';\n    case gl.INVALID_OPERATION:\n      return 'INVALID_OPERATION';\n    case gl.INVALID_FRAMEBUFFER_OPERATION:\n      return 'INVALID_FRAMEBUFFER_OPERATION';\n    case gl.OUT_OF_MEMORY:\n      return 'OUT_OF_MEMORY';\n    case gl.CONTEXT_LOST_WEBGL:\n      return 'CONTEXT_LOST_WEBGL';\n    default:\n      return \"Unknown error code \".concat(status);\n  }\n}\nexport function getExtensionOrThrow(gl, extensionName) {\n  return throwIfNull(gl, () => gl.getExtension(extensionName), 'Extension \"' + extensionName + '\" not supported on this browser.');\n}\nexport function createVertexShader(gl, vertexShaderSource) {\n  const vertexShader = throwIfNull(gl, () => gl.createShader(gl.VERTEX_SHADER), 'Unable to create vertex WebGLShader.');\n  callAndCheck(gl, () => gl.shaderSource(vertexShader, vertexShaderSource));\n  callAndCheck(gl, () => gl.compileShader(vertexShader));\n  if (gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS) === false) {\n    console.log(gl.getShaderInfoLog(vertexShader));\n    throw new Error('Failed to compile vertex shader.');\n  }\n  return vertexShader;\n}\nexport function createFragmentShader(gl, fragmentShaderSource) {\n  const fragmentShader = throwIfNull(gl, () => gl.createShader(gl.FRAGMENT_SHADER), 'Unable to create fragment WebGLShader.');\n  callAndCheck(gl, () => gl.shaderSource(fragmentShader, fragmentShaderSource));\n  callAndCheck(gl, () => gl.compileShader(fragmentShader));\n  if (env().get('ENGINE_COMPILE_ONLY')) {\n    return fragmentShader;\n  }\n  if (gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS) === false) {\n    logShaderSourceAndInfoLog(fragmentShaderSource, gl.getShaderInfoLog(fragmentShader));\n    throw new Error('Failed to compile fragment shader.');\n  }\n  return fragmentShader;\n}\nconst lineNumberRegex = /ERROR: [0-9]+:([0-9]+):/g;\nexport function logShaderSourceAndInfoLog(shaderSource, shaderInfoLog) {\n  const lineNumberRegexResult = lineNumberRegex.exec(shaderInfoLog);\n  if (lineNumberRegexResult == null) {\n    console.log(\"Couldn't parse line number in error: \".concat(shaderInfoLog));\n    console.log(shaderSource);\n    return;\n  }\n  const lineNumber = +lineNumberRegexResult[1];\n  const shaderLines = shaderSource.split('\\n');\n  const pad = shaderLines.length.toString().length + 2;\n  const linesWithLineNumbers = shaderLines.map((line, lineNumber) => util.rightPad((lineNumber + 1).toString(), pad) + line);\n  let maxLineLength = 0;\n  for (let i = 0; i < linesWithLineNumbers.length; i++) {\n    maxLineLength = Math.max(linesWithLineNumbers[i].length, maxLineLength);\n  }\n  const beforeErrorLines = linesWithLineNumbers.slice(0, lineNumber - 1);\n  const errorLine = linesWithLineNumbers.slice(lineNumber - 1, lineNumber);\n  const afterErrorLines = linesWithLineNumbers.slice(lineNumber);\n  console.log(beforeErrorLines.join('\\n'));\n  console.log(shaderInfoLog.split('\\n')[0]);\n  console.log(\"%c \".concat(util.rightPad(errorLine[0], maxLineLength)), 'border:1px solid red; background-color:#e3d2d2; color:#a61717');\n  console.log(afterErrorLines.join('\\n'));\n}\nexport function createProgram(gl) {\n  return throwIfNull(gl, () => gl.createProgram(), 'Unable to create WebGLProgram.');\n}\nexport function linkProgram(gl, program) {\n  callAndCheck(gl, () => gl.linkProgram(program));\n  if (env().get('ENGINE_COMPILE_ONLY')) {\n    return;\n  }\n  if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {\n    console.log(gl.getProgramInfoLog(program));\n    throw new Error('Failed to link vertex and fragment shaders.');\n  }\n}\n/// validateProgram is effectively \"If we `useProgram(program); drawArrays();`,\n/// give feedback in log about perf/correctness warnings or errors that would\n/// occur.\"\n/// So make sure we set up all vertex/texture/sampler/uniform data before\n/// calling validateProgram!\nexport function validateProgram(gl, program) {\n  callAndCheck(gl, () => gl.validateProgram(program));\n  if (gl.getProgramParameter(program, gl.VALIDATE_STATUS) === false) {\n    console.log(gl.getProgramInfoLog(program));\n    throw new Error('Shader program validation failed.');\n  }\n}\nexport function createStaticVertexBuffer(gl, data) {\n  const buffer = throwIfNull(gl, () => gl.createBuffer(), 'Unable to create WebGLBuffer');\n  callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, buffer));\n  callAndCheck(gl, () => gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW));\n  return buffer;\n}\nexport function createStaticIndexBuffer(gl, data) {\n  const buffer = throwIfNull(gl, () => gl.createBuffer(), 'Unable to create WebGLBuffer');\n  callAndCheck(gl, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer));\n  callAndCheck(gl, () => gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW));\n  return buffer;\n}\nexport function getNumChannels() {\n  if (env().getNumber('WEBGL_VERSION') === 2) {\n    return 1;\n  }\n  return 4;\n}\nexport function createTexture(gl) {\n  return throwIfNull(gl, () => gl.createTexture(), 'Unable to create WebGLTexture.');\n}\nexport function validateTextureSize(width, height) {\n  const maxTextureSize = env().getNumber('WEBGL_MAX_TEXTURE_SIZE');\n  if (width <= 0 || height <= 0) {\n    const requested = \"[\".concat(width, \"x\").concat(height, \"]\");\n    throw new Error('Requested texture size ' + requested + ' is invalid.');\n  }\n  if (width > maxTextureSize || height > maxTextureSize) {\n    const requested = \"[\".concat(width, \"x\").concat(height, \"]\");\n    const max = \"[\".concat(maxTextureSize, \"x\").concat(maxTextureSize, \"]\");\n    throw new Error('Requested texture size ' + requested + ' greater than WebGL maximum on this browser / GPU ' + max + '.');\n  }\n}\nexport function createFramebuffer(gl) {\n  return throwIfNull(gl, () => gl.createFramebuffer(), 'Unable to create WebGLFramebuffer.');\n}\nexport function bindVertexBufferToProgramAttribute(gl, program, attribute, buffer, arrayEntriesPerItem, itemStrideInBytes, itemOffsetInBytes) {\n  const loc = gl.getAttribLocation(program, attribute);\n  if (loc === -1) {\n    // The GPU compiler decided to strip out this attribute because it's unused,\n    // thus no need to bind.\n    return false;\n  }\n  callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, buffer));\n  callAndCheck(gl, () => gl.vertexAttribPointer(loc, arrayEntriesPerItem, gl.FLOAT, false, itemStrideInBytes, itemOffsetInBytes));\n  callAndCheck(gl, () => gl.enableVertexAttribArray(loc));\n  return true;\n}\nexport function bindTextureUnit(gl, texture, textureUnit) {\n  validateTextureUnit(gl, textureUnit);\n  callAndCheck(gl, () => gl.activeTexture(gl.TEXTURE0 + textureUnit));\n  callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));\n}\nexport function unbindTextureUnit(gl, textureUnit) {\n  validateTextureUnit(gl, textureUnit);\n  callAndCheck(gl, () => gl.activeTexture(gl.TEXTURE0 + textureUnit));\n  callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));\n}\nexport function getProgramUniformLocationOrThrow(gl, program, uniformName) {\n  return throwIfNull(gl, () => gl.getUniformLocation(program, uniformName), 'uniform \"' + uniformName + '\" not present in program.');\n}\nexport function getProgramUniformLocation(gl, program, uniformName) {\n  return gl.getUniformLocation(program, uniformName);\n}\nexport function bindTextureToProgramUniformSampler(gl, texture, uniformSamplerLocation, textureUnit) {\n  callAndCheck(gl, () => bindTextureUnit(gl, texture, textureUnit));\n  callAndCheck(gl, () => gl.uniform1i(uniformSamplerLocation, textureUnit));\n}\nexport function bindCanvasToFramebuffer(gl) {\n  callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, null));\n  callAndCheck(gl, () => gl.viewport(0, 0, gl.canvas.width, gl.canvas.height));\n  callAndCheck(gl, () => gl.scissor(0, 0, gl.canvas.width, gl.canvas.height));\n}\nexport function bindColorTextureToFramebuffer(gl, texture, framebuffer) {\n  callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));\n  callAndCheck(gl, () => gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0));\n}\nexport function unbindColorTextureFromFramebuffer(gl, framebuffer) {\n  callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));\n  callAndCheck(gl, () => gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0));\n}\nexport function validateFramebuffer(gl) {\n  const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n  if (status !== gl.FRAMEBUFFER_COMPLETE) {\n    throw new Error('Error binding framebuffer: ' + getFramebufferErrorMessage(gl, status));\n  }\n}\nexport function getFramebufferErrorMessage(gl, status) {\n  switch (status) {\n    case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:\n      return 'FRAMEBUFFER_INCOMPLETE_ATTACHMENT';\n    case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:\n      return 'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT';\n    case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:\n      return 'FRAMEBUFFER_INCOMPLETE_DIMENSIONS';\n    case gl.FRAMEBUFFER_UNSUPPORTED:\n      return 'FRAMEBUFFER_UNSUPPORTED';\n    default:\n      return \"unknown error \".concat(status);\n  }\n}\nfunction throwIfNull(gl, returnTOrNull, failureMessage) {\n  const tOrNull = callAndCheck(gl, () => returnTOrNull());\n  if (tOrNull == null) {\n    throw new Error(failureMessage);\n  }\n  return tOrNull;\n}\nfunction validateTextureUnit(gl, textureUnit) {\n  const maxTextureUnit = gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1;\n  const glTextureUnit = textureUnit + gl.TEXTURE0;\n  if (glTextureUnit < gl.TEXTURE0 || glTextureUnit > maxTextureUnit) {\n    const textureUnitRange = \"[gl.TEXTURE0, gl.TEXTURE\".concat(maxTextureUnit, \"]\");\n    throw new Error(\"textureUnit must be in \".concat(textureUnitRange, \".\"));\n  }\n}\nexport function getBatchDim(shape) {\n  let dimsToSkip = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n  return util.sizeFromShape(shape.slice(0, shape.length - dimsToSkip));\n}\nexport function getRowsCols(shape) {\n  if (shape.length === 0) {\n    throw Error('Cannot get rows and columns of an empty shape array.');\n  }\n  return [shape.length > 1 ? shape[shape.length - 2] : 1, shape[shape.length - 1]];\n}\nexport function getShapeAs3D(shape) {\n  let shapeAs3D = [1, 1, 1];\n  const isScalar = shape.length === 0 || shape.length === 1 && shape[0] === 1;\n  if (!isScalar) {\n    shapeAs3D = [getBatchDim(shape), ...getRowsCols(shape)];\n  }\n  return shapeAs3D;\n}\nexport function getTextureShapeFromLogicalShape(logShape) {\n  let isPacked = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  let maxTexSize = env().getNumber('WEBGL_MAX_TEXTURE_SIZE');\n  let maxSizeForNarrowTex = env().getNumber('WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE');\n  if (maxSizeForNarrowTex === Infinity && env().getBool('WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE')) {\n    maxSizeForNarrowTex = maxTexSize / 2;\n  }\n  if (isPacked) {\n    maxTexSize = maxTexSize * 2;\n    maxSizeForNarrowTex = maxSizeForNarrowTex * 2;\n    // This logic ensures we accurately count the number of packed texels needed\n    // to accommodate the tensor. We can only pack values in the same texel if\n    // they are from adjacent pairs of rows/cols within the same batch. So if a\n    // tensor has 3 rows, we pretend it has 4 rows in order to account for the\n    // fact that the texels containing the third row are half empty.\n    logShape = logShape.map((d, i) => i >= logShape.length - 2 ? util.nearestLargerEven(logShape[i]) : logShape[i]);\n    // Packed texture height is at least 2 (the channel height of a single\n    // texel).\n    if (logShape.length === 1) {\n      logShape = [2, logShape[0]];\n    }\n  }\n  // If logical shape is 2, we don't squeeze, since we want to match physical.\n  if (logShape.length !== 2) {\n    const squeezeResult = util.squeezeShape(logShape);\n    logShape = squeezeResult.newShape;\n  }\n  let size = util.sizeFromShape(logShape);\n  let textureShape = null;\n  if (logShape.length <= 1 && size <= maxTexSize) {\n    textureShape = [1, size];\n  } else if (logShape.length === 2 && logShape[0] <= maxTexSize && logShape[1] <= maxTexSize) {\n    textureShape = logShape;\n  } else if (logShape.length === 3 && logShape[0] * logShape[1] <= maxTexSize && logShape[2] <= maxTexSize) {\n    textureShape = [logShape[0] * logShape[1], logShape[2]];\n  } else if (logShape.length === 3 && logShape[0] <= maxTexSize && logShape[1] * logShape[2] <= maxTexSize) {\n    textureShape = [logShape[0], logShape[1] * logShape[2]];\n  } else if (logShape.length === 4 && logShape[0] * logShape[1] * logShape[2] <= maxTexSize && logShape[3] <= maxTexSize) {\n    textureShape = [logShape[0] * logShape[1] * logShape[2], logShape[3]];\n  } else if (logShape.length === 4 && logShape[0] <= maxTexSize && logShape[1] * logShape[2] * logShape[3] <= maxTexSize) {\n    textureShape = [logShape[0], logShape[1] * logShape[2] * logShape[3]];\n  }\n  // true if one edge length is 1 (1 or 2, if packed), while another edge\n  // length exceeds maxSizeForNarrowTex.\n  const isLongNarrowTex = textureShape != null && Math.max(...textureShape) > maxSizeForNarrowTex && Math.min(...textureShape) <= (isPacked ? 2 : 1) && Math.min(...textureShape) > 0;\n  if (textureShape == null || isLongNarrowTex) {\n    if (isPacked) {\n      // For packed textures size equals the number of channels required to\n      // accommodate the texture data. However in order to squarify such that\n      // inner dimensions stay even, we rewrite size to equal the number of\n      // texels. Then in the return statement we rehydrate the squarified\n      // dimensions to channel units.\n      const batchDim = getBatchDim(logShape);\n      let rows = 2,\n        cols = 2;\n      if (logShape.length) {\n        [rows, cols] = getRowsCols(logShape);\n      }\n      size = batchDim * (rows / 2) * (cols / 2);\n      textureShape = util.sizeToSquarishShape(size).map(d => d * 2);\n    } else {\n      textureShape = util.sizeToSquarishShape(size);\n    }\n  }\n  return textureShape;\n}\nfunction isEven(n) {\n  return n % 2 === 0;\n}\n/**\n * This determines whether reshaping a packed texture requires rearranging\n * the data within the texture, assuming 2x2 packing.\n */\nexport function isReshapeFree(shape1, shape2) {\n  shape1 = shape1.slice(-2);\n  shape2 = shape2.slice(-2);\n  if (util.arraysEqual(shape1, shape2)) {\n    return true;\n  }\n  if (!shape1.length || !shape2.length) {\n    // One of the shapes is a scalar.\n    return true;\n  }\n  if (shape1[0] === 0 || shape1[1] === 0 || shape2[0] === 0 || shape2[1] === 0) {\n    return true;\n  }\n  if (shape1.length !== shape2.length) {\n    // One of the shapes is a vector.\n    const shape1Cols = shape1.slice(-1)[0];\n    const shape2Cols = shape2.slice(-1)[0];\n    if (shape1Cols === shape2Cols) {\n      return true;\n    }\n    if (isEven(shape1Cols) && isEven(shape2Cols) && (shape1[0] === 1 || shape2[0] === 1)) {\n      return true;\n    }\n  }\n  return shape1[1] === shape2[1] && isEven(shape1[0]) && isEven(shape2[0]);\n}\n// We cache webgl params because the environment gets reset between\n// unit tests and we don't want to constantly query the WebGLContext for\n// MAX_TEXTURE_SIZE.\nlet MAX_TEXTURE_SIZE;\nlet MAX_TEXTURES_IN_SHADER;\nexport function getWebGLMaxTextureSize(webGLVersion) {\n  if (MAX_TEXTURE_SIZE == null) {\n    const gl = getWebGLContext(webGLVersion);\n    MAX_TEXTURE_SIZE = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n  }\n  return MAX_TEXTURE_SIZE;\n}\nexport function resetMaxTextureSize() {\n  MAX_TEXTURE_SIZE = null;\n}\nexport function resetMaxTexturesInShader() {\n  MAX_TEXTURES_IN_SHADER = null;\n}\nexport function getMaxTexturesInShader(webGLVersion) {\n  if (MAX_TEXTURES_IN_SHADER == null) {\n    const gl = getWebGLContext(webGLVersion);\n    MAX_TEXTURES_IN_SHADER = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n  }\n  // We cap at 16 to avoid spurious runtime \"memory exhausted\" error.\n  return Math.min(16, MAX_TEXTURES_IN_SHADER);\n}\nexport function getWebGLDisjointQueryTimerVersion(webGLVersion) {\n  if (webGLVersion === 0) {\n    return 0;\n  }\n  let queryTimerVersion;\n  const gl = getWebGLContext(webGLVersion);\n  if (hasExtension(gl, 'EXT_disjoint_timer_query_webgl2') && webGLVersion === 2) {\n    queryTimerVersion = 2;\n  } else if (hasExtension(gl, 'EXT_disjoint_timer_query')) {\n    queryTimerVersion = 1;\n  } else {\n    queryTimerVersion = 0;\n  }\n  return queryTimerVersion;\n}\nexport function hasExtension(gl, extensionName) {\n  const ext = gl.getExtension(extensionName);\n  return ext != null;\n}\nexport function isWebGLVersionEnabled(webGLVersion) {\n  try {\n    const gl = getWebGLContext(webGLVersion);\n    if (gl != null) {\n      return true;\n    }\n  } catch (e) {\n    console.log('Error when getting WebGL context: ', e);\n    return false;\n  }\n  return false;\n}\nexport function isCapableOfRenderingToFloatTexture(webGLVersion) {\n  if (webGLVersion === 0) {\n    return false;\n  }\n  const gl = getWebGLContext(webGLVersion);\n  if (webGLVersion === 1) {\n    if (!hasExtension(gl, 'OES_texture_float')) {\n      return false;\n    }\n  } else {\n    if (!hasExtension(gl, 'EXT_color_buffer_float')) {\n      return false;\n    }\n  }\n  const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);\n  return isFrameBufferComplete;\n}\n/**\n * Check if we can download values from a float/half-float texture.\n *\n * Note that for performance reasons we use binding a texture to a framebuffer\n * as a proxy for ability to download float values later using readPixels. The\n * texture params of this texture will not match those in readPixels exactly\n * but if we are unable to bind some kind of float texture to the frameBuffer\n * then we definitely will not be able to read float values from it.\n */\nexport function isDownloadFloatTextureEnabled(webGLVersion) {\n  if (webGLVersion === 0) {\n    return false;\n  }\n  const gl = getWebGLContext(webGLVersion);\n  if (webGLVersion === 1) {\n    if (!hasExtension(gl, 'OES_texture_float')) {\n      return false;\n    }\n    if (!hasExtension(gl, 'WEBGL_color_buffer_float')) {\n      return false;\n    }\n  } else {\n    if (hasExtension(gl, 'EXT_color_buffer_float')) {\n      return createFloatTextureAndBindToFramebuffer(gl);\n    }\n    const COLOR_BUFFER_HALF_FLOAT = 'EXT_color_buffer_half_float';\n    if (hasExtension(gl, COLOR_BUFFER_HALF_FLOAT)) {\n      const textureHalfFloatExtension = gl.getExtension(COLOR_BUFFER_HALF_FLOAT);\n      return createHalfFloatTextureAndBindToFramebuffer(gl, textureHalfFloatExtension);\n    }\n    return false;\n  }\n  const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);\n  return isFrameBufferComplete;\n}\nfunction createFloatTextureAndBindToFramebuffer(gl) {\n  const texConfig = getTextureConfig(gl);\n  const texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  const width = 1;\n  const height = 1;\n  gl.texImage2D(gl.TEXTURE_2D, 0, texConfig.internalFormatFloat, width, height, 0, texConfig.textureFormatFloat, texConfig.textureTypeFloat, null);\n  const frameBuffer = gl.createFramebuffer();\n  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n  const isFrameBufferComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;\n  gl.bindTexture(gl.TEXTURE_2D, null);\n  gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n  gl.deleteTexture(texture);\n  gl.deleteFramebuffer(frameBuffer);\n  return isFrameBufferComplete;\n}\nfunction createHalfFloatTextureAndBindToFramebuffer(\n// tslint:disable-next-line:no-any\ngl, textureHalfFloatExtension) {\n  const texConfig = getTextureConfig(gl, textureHalfFloatExtension);\n  const texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  const width = 1;\n  const height = 1;\n  gl.texImage2D(gl.TEXTURE_2D, 0, texConfig.internalFormatHalfFloat, width, height, 0, texConfig.textureFormatFloat, texConfig.textureTypeHalfFloat, null);\n  const frameBuffer = gl.createFramebuffer();\n  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n  const isFrameBufferComplete = gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;\n  gl.bindTexture(gl.TEXTURE_2D, null);\n  gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n  gl.deleteTexture(texture);\n  gl.deleteFramebuffer(frameBuffer);\n  return isFrameBufferComplete;\n}\nexport function isWebGLFenceEnabled(webGLVersion) {\n  if (webGLVersion !== 2) {\n    return false;\n  }\n  const gl = getWebGLContext(webGLVersion);\n  // tslint:disable-next-line:no-any\n  const isEnabled = gl.fenceSync != null;\n  return isEnabled;\n}\nexport function assertNotComplex(tensor, opName) {\n  if (!Array.isArray(tensor)) {\n    tensor = [tensor];\n  }\n  tensor.forEach(t => {\n    if (t != null) {\n      util.assert(t.dtype !== 'complex64', () => \"\".concat(opName, \" does not support complex64 tensors \") + 'in the WebGL backend.');\n    }\n  });\n}","map":{"version":3,"names":["env","util","getWebGLContext","getTextureConfig","callAndCheck","gl","func","returnValue","getBool","checkWebGLError","error","getError","NO_ERROR","Error","getWebGLErrorMessage","MIN_FLOAT16","MAX_FLOAT16","canBeRepresented","num","Math","abs","status","INVALID_ENUM","INVALID_VALUE","INVALID_OPERATION","INVALID_FRAMEBUFFER_OPERATION","OUT_OF_MEMORY","CONTEXT_LOST_WEBGL","concat","getExtensionOrThrow","extensionName","throwIfNull","getExtension","createVertexShader","vertexShaderSource","vertexShader","createShader","VERTEX_SHADER","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","console","log","getShaderInfoLog","createFragmentShader","fragmentShaderSource","fragmentShader","FRAGMENT_SHADER","get","logShaderSourceAndInfoLog","lineNumberRegex","shaderInfoLog","lineNumberRegexResult","exec","lineNumber","shaderLines","split","pad","length","toString","linesWithLineNumbers","map","line","rightPad","maxLineLength","i","max","beforeErrorLines","slice","errorLine","afterErrorLines","join","createProgram","linkProgram","program","getProgramParameter","LINK_STATUS","getProgramInfoLog","validateProgram","VALIDATE_STATUS","createStaticVertexBuffer","data","buffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","createStaticIndexBuffer","ELEMENT_ARRAY_BUFFER","getNumChannels","getNumber","createTexture","validateTextureSize","width","height","maxTextureSize","requested","createFramebuffer","bindVertexBufferToProgramAttribute","attribute","arrayEntriesPerItem","itemStrideInBytes","itemOffsetInBytes","loc","getAttribLocation","vertexAttribPointer","FLOAT","enableVertexAttribArray","bindTextureUnit","texture","textureUnit","validateTextureUnit","activeTexture","TEXTURE0","bindTexture","TEXTURE_2D","unbindTextureUnit","getProgramUniformLocationOrThrow","uniformName","getUniformLocation","getProgramUniformLocation","bindTextureToProgramUniformSampler","uniformSamplerLocation","uniform1i","bindCanvasToFramebuffer","bindFramebuffer","FRAMEBUFFER","viewport","canvas","scissor","bindColorTextureToFramebuffer","framebuffer","framebufferTexture2D","COLOR_ATTACHMENT0","unbindColorTextureFromFramebuffer","validateFramebuffer","checkFramebufferStatus","FRAMEBUFFER_COMPLETE","getFramebufferErrorMessage","FRAMEBUFFER_INCOMPLETE_ATTACHMENT","FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT","FRAMEBUFFER_INCOMPLETE_DIMENSIONS","FRAMEBUFFER_UNSUPPORTED","returnTOrNull","failureMessage","tOrNull","maxTextureUnit","MAX_COMBINED_TEXTURE_IMAGE_UNITS","glTextureUnit","textureUnitRange","getBatchDim","shape","dimsToSkip","arguments","undefined","sizeFromShape","getRowsCols","getShapeAs3D","shapeAs3D","isScalar","getTextureShapeFromLogicalShape","logShape","isPacked","maxTexSize","maxSizeForNarrowTex","Infinity","d","nearestLargerEven","squeezeResult","squeezeShape","newShape","size","textureShape","isLongNarrowTex","min","batchDim","rows","cols","sizeToSquarishShape","isEven","n","isReshapeFree","shape1","shape2","arraysEqual","shape1Cols","shape2Cols","MAX_TEXTURE_SIZE","MAX_TEXTURES_IN_SHADER","getWebGLMaxTextureSize","webGLVersion","getParameter","resetMaxTextureSize","resetMaxTexturesInShader","getMaxTexturesInShader","MAX_TEXTURE_IMAGE_UNITS","getWebGLDisjointQueryTimerVersion","queryTimerVersion","hasExtension","ext","isWebGLVersionEnabled","e","isCapableOfRenderingToFloatTexture","isFrameBufferComplete","createFloatTextureAndBindToFramebuffer","isDownloadFloatTextureEnabled","COLOR_BUFFER_HALF_FLOAT","textureHalfFloatExtension","createHalfFloatTextureAndBindToFramebuffer","texConfig","texImage2D","internalFormatFloat","textureFormatFloat","textureTypeFloat","frameBuffer","deleteTexture","deleteFramebuffer","internalFormatHalfFloat","textureTypeHalfFloat","isWebGLFenceEnabled","isEnabled","fenceSync","assertNotComplex","tensor","opName","Array","isArray","forEach","t","assert","dtype"],"sources":["E:\\office work\\hositngYOLOgithub\\tfjs-backend-webgl\\src\\webgl_util.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {env, TensorInfo, util} from '@tensorflow/tfjs-core';\n\nimport {getWebGLContext} from './canvas_util';\nimport {getTextureConfig} from './tex_util';\n\nexport function callAndCheck<T>(gl: WebGLRenderingContext, func: () => T): T {\n  const returnValue = func();\n  if (env().getBool('DEBUG')) {\n    checkWebGLError(gl);\n  }\n  return returnValue;\n}\n\nfunction checkWebGLError(gl: WebGLRenderingContext) {\n  const error = gl.getError();\n  if (error !== gl.NO_ERROR) {\n    throw new Error('WebGL Error: ' + getWebGLErrorMessage(gl, error));\n  }\n}\n\n// https://en.wikipedia.org/wiki/Half-precision_floating-point_format\nconst MIN_FLOAT16 = 5.96e-8;\nconst MAX_FLOAT16 = 65504;\n\nexport function canBeRepresented(num: number): boolean {\n  if (env().getBool('WEBGL_RENDER_FLOAT32_ENABLED') || num === 0 ||\n      (MIN_FLOAT16 < Math.abs(num) && Math.abs(num) < MAX_FLOAT16)) {\n    return true;\n  }\n  return false;\n}\n\nexport function getWebGLErrorMessage(\n    gl: WebGLRenderingContext, status: number): string {\n  switch (status) {\n    case gl.NO_ERROR:\n      return 'NO_ERROR';\n    case gl.INVALID_ENUM:\n      return 'INVALID_ENUM';\n    case gl.INVALID_VALUE:\n      return 'INVALID_VALUE';\n    case gl.INVALID_OPERATION:\n      return 'INVALID_OPERATION';\n    case gl.INVALID_FRAMEBUFFER_OPERATION:\n      return 'INVALID_FRAMEBUFFER_OPERATION';\n    case gl.OUT_OF_MEMORY:\n      return 'OUT_OF_MEMORY';\n    case gl.CONTEXT_LOST_WEBGL:\n      return 'CONTEXT_LOST_WEBGL';\n    default:\n      return `Unknown error code ${status}`;\n  }\n}\n\nexport function getExtensionOrThrow(\n    gl: WebGLRenderingContext, extensionName: string): {} {\n  return throwIfNull<{}>(\n      gl, () => gl.getExtension(extensionName),\n      'Extension \"' + extensionName + '\" not supported on this browser.');\n}\n\nexport function createVertexShader(\n    gl: WebGLRenderingContext, vertexShaderSource: string): WebGLShader {\n  const vertexShader: WebGLShader = throwIfNull<WebGLShader>(\n      gl, () => gl.createShader(gl.VERTEX_SHADER),\n      'Unable to create vertex WebGLShader.');\n  callAndCheck(gl, () => gl.shaderSource(vertexShader, vertexShaderSource));\n  callAndCheck(gl, () => gl.compileShader(vertexShader));\n  if (gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS) === false) {\n    console.log(gl.getShaderInfoLog(vertexShader));\n    throw new Error('Failed to compile vertex shader.');\n  }\n  return vertexShader;\n}\n\nexport function createFragmentShader(\n    gl: WebGLRenderingContext, fragmentShaderSource: string): WebGLShader {\n  const fragmentShader: WebGLShader = throwIfNull<WebGLShader>(\n      gl, () => gl.createShader(gl.FRAGMENT_SHADER),\n      'Unable to create fragment WebGLShader.');\n  callAndCheck(gl, () => gl.shaderSource(fragmentShader, fragmentShaderSource));\n  callAndCheck(gl, () => gl.compileShader(fragmentShader));\n  if (env().get('ENGINE_COMPILE_ONLY')) {\n    return fragmentShader;\n  }\n  if (gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS) === false) {\n    logShaderSourceAndInfoLog(\n        fragmentShaderSource, gl.getShaderInfoLog(fragmentShader));\n    throw new Error('Failed to compile fragment shader.');\n  }\n  return fragmentShader;\n}\n\nconst lineNumberRegex = /ERROR: [0-9]+:([0-9]+):/g;\nexport function logShaderSourceAndInfoLog(\n    shaderSource: string, shaderInfoLog: string) {\n  const lineNumberRegexResult = lineNumberRegex.exec(shaderInfoLog);\n  if (lineNumberRegexResult == null) {\n    console.log(`Couldn't parse line number in error: ${shaderInfoLog}`);\n    console.log(shaderSource);\n    return;\n  }\n\n  const lineNumber = +lineNumberRegexResult[1];\n\n  const shaderLines = shaderSource.split('\\n');\n  const pad = shaderLines.length.toString().length + 2;\n  const linesWithLineNumbers = shaderLines.map(\n      (line, lineNumber) =>\n          util.rightPad((lineNumber + 1).toString(), pad) + line);\n  let maxLineLength = 0;\n  for (let i = 0; i < linesWithLineNumbers.length; i++) {\n    maxLineLength = Math.max(linesWithLineNumbers[i].length, maxLineLength);\n  }\n\n  const beforeErrorLines = linesWithLineNumbers.slice(0, lineNumber - 1);\n  const errorLine = linesWithLineNumbers.slice(lineNumber - 1, lineNumber);\n  const afterErrorLines = linesWithLineNumbers.slice(lineNumber);\n\n  console.log(beforeErrorLines.join('\\n'));\n  console.log(shaderInfoLog.split('\\n')[0]);\n  console.log(\n      `%c ${util.rightPad(errorLine[0], maxLineLength)}`,\n      'border:1px solid red; background-color:#e3d2d2; color:#a61717');\n  console.log(afterErrorLines.join('\\n'));\n}\n\nexport function createProgram(gl: WebGLRenderingContext): WebGLProgram {\n  return throwIfNull<WebGLProgram>(\n      gl, () => gl.createProgram(), 'Unable to create WebGLProgram.');\n}\n\nexport function linkProgram(gl: WebGLRenderingContext, program: WebGLProgram) {\n  callAndCheck(gl, () => gl.linkProgram(program));\n  if (env().get('ENGINE_COMPILE_ONLY')) {\n    return;\n  }\n  if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {\n    console.log(gl.getProgramInfoLog(program));\n    throw new Error('Failed to link vertex and fragment shaders.');\n  }\n}\n\n/// validateProgram is effectively \"If we `useProgram(program); drawArrays();`,\n/// give feedback in log about perf/correctness warnings or errors that would\n/// occur.\"\n/// So make sure we set up all vertex/texture/sampler/uniform data before\n/// calling validateProgram!\nexport function validateProgram(\n    gl: WebGLRenderingContext, program: WebGLProgram) {\n  callAndCheck(gl, () => gl.validateProgram(program));\n  if (gl.getProgramParameter(program, gl.VALIDATE_STATUS) === false) {\n    console.log(gl.getProgramInfoLog(program));\n    throw new Error('Shader program validation failed.');\n  }\n}\n\nexport function createStaticVertexBuffer(\n    gl: WebGLRenderingContext, data: Float32Array): WebGLBuffer {\n  const buffer: WebGLBuffer = throwIfNull<WebGLBuffer>(\n      gl, () => gl.createBuffer(), 'Unable to create WebGLBuffer');\n  callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, buffer));\n  callAndCheck(gl, () => gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW));\n  return buffer;\n}\n\nexport function createStaticIndexBuffer(\n    gl: WebGLRenderingContext, data: Uint16Array): WebGLBuffer {\n  const buffer: WebGLBuffer = throwIfNull<WebGLBuffer>(\n      gl, () => gl.createBuffer(), 'Unable to create WebGLBuffer');\n  callAndCheck(gl, () => gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer));\n  callAndCheck(\n      gl, () => gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW));\n  return buffer;\n}\n\nexport function getNumChannels(): number {\n  if (env().getNumber('WEBGL_VERSION') === 2) {\n    return 1;\n  }\n  return 4;\n}\n\nexport function createTexture(gl: WebGLRenderingContext): WebGLTexture {\n  return throwIfNull<WebGLTexture>(\n      gl, () => gl.createTexture(), 'Unable to create WebGLTexture.');\n}\n\nexport function validateTextureSize(width: number, height: number) {\n  const maxTextureSize = env().getNumber('WEBGL_MAX_TEXTURE_SIZE');\n  if ((width <= 0) || (height <= 0)) {\n    const requested = `[${width}x${height}]`;\n    throw new Error('Requested texture size ' + requested + ' is invalid.');\n  }\n  if ((width > maxTextureSize) || (height > maxTextureSize)) {\n    const requested = `[${width}x${height}]`;\n    const max = `[${maxTextureSize}x${maxTextureSize}]`;\n    throw new Error(\n        'Requested texture size ' + requested +\n        ' greater than WebGL maximum on this browser / GPU ' + max + '.');\n  }\n}\n\nexport function createFramebuffer(gl: WebGLRenderingContext): WebGLFramebuffer {\n  return throwIfNull<WebGLFramebuffer>(\n      gl, () => gl.createFramebuffer(), 'Unable to create WebGLFramebuffer.');\n}\n\nexport function bindVertexBufferToProgramAttribute(\n    gl: WebGLRenderingContext, program: WebGLProgram, attribute: string,\n    buffer: WebGLBuffer, arrayEntriesPerItem: number, itemStrideInBytes: number,\n    itemOffsetInBytes: number): boolean {\n  const loc = gl.getAttribLocation(program, attribute);\n  if (loc === -1) {\n    // The GPU compiler decided to strip out this attribute because it's unused,\n    // thus no need to bind.\n    return false;\n  }\n  callAndCheck(gl, () => gl.bindBuffer(gl.ARRAY_BUFFER, buffer));\n  callAndCheck(\n      gl,\n      () => gl.vertexAttribPointer(\n          loc, arrayEntriesPerItem, gl.FLOAT, false, itemStrideInBytes,\n          itemOffsetInBytes));\n  callAndCheck(gl, () => gl.enableVertexAttribArray(loc));\n  return true;\n}\n\nexport function bindTextureUnit(\n    gl: WebGLRenderingContext, texture: WebGLTexture, textureUnit: number) {\n  validateTextureUnit(gl, textureUnit);\n  callAndCheck(gl, () => gl.activeTexture(gl.TEXTURE0 + textureUnit));\n  callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, texture));\n}\n\nexport function unbindTextureUnit(\n    gl: WebGLRenderingContext, textureUnit: number) {\n  validateTextureUnit(gl, textureUnit);\n  callAndCheck(gl, () => gl.activeTexture(gl.TEXTURE0 + textureUnit));\n  callAndCheck(gl, () => gl.bindTexture(gl.TEXTURE_2D, null));\n}\n\nexport function getProgramUniformLocationOrThrow(\n    gl: WebGLRenderingContext, program: WebGLProgram,\n    uniformName: string): WebGLUniformLocation {\n  return throwIfNull<WebGLUniformLocation>(\n      gl, () => gl.getUniformLocation(program, uniformName),\n      'uniform \"' + uniformName + '\" not present in program.');\n}\n\nexport function getProgramUniformLocation(\n    gl: WebGLRenderingContext, program: WebGLProgram,\n    uniformName: string): WebGLUniformLocation {\n  return gl.getUniformLocation(program, uniformName);\n}\n\nexport function bindTextureToProgramUniformSampler(\n    gl: WebGLRenderingContext, texture: WebGLTexture,\n    uniformSamplerLocation: WebGLUniformLocation, textureUnit: number) {\n  callAndCheck(gl, () => bindTextureUnit(gl, texture, textureUnit));\n  callAndCheck(gl, () => gl.uniform1i(uniformSamplerLocation, textureUnit));\n}\n\nexport function bindCanvasToFramebuffer(gl: WebGLRenderingContext) {\n  callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, null));\n  callAndCheck(gl, () => gl.viewport(0, 0, gl.canvas.width, gl.canvas.height));\n  callAndCheck(gl, () => gl.scissor(0, 0, gl.canvas.width, gl.canvas.height));\n}\n\nexport function bindColorTextureToFramebuffer(\n    gl: WebGLRenderingContext, texture: WebGLTexture,\n    framebuffer: WebGLFramebuffer) {\n  callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));\n  callAndCheck(\n      gl,\n      () => gl.framebufferTexture2D(\n          gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0));\n}\n\nexport function unbindColorTextureFromFramebuffer(\n    gl: WebGLRenderingContext, framebuffer: WebGLFramebuffer) {\n  callAndCheck(gl, () => gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer));\n  callAndCheck(\n      gl,\n      () => gl.framebufferTexture2D(\n          gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0));\n}\n\nexport function validateFramebuffer(gl: WebGLRenderingContext) {\n  const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n  if (status !== gl.FRAMEBUFFER_COMPLETE) {\n    throw new Error(\n        'Error binding framebuffer: ' + getFramebufferErrorMessage(gl, status));\n  }\n}\n\nexport function getFramebufferErrorMessage(\n    gl: WebGLRenderingContext, status: number): string {\n  switch (status) {\n    case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:\n      return 'FRAMEBUFFER_INCOMPLETE_ATTACHMENT';\n    case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:\n      return 'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT';\n    case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:\n      return 'FRAMEBUFFER_INCOMPLETE_DIMENSIONS';\n    case gl.FRAMEBUFFER_UNSUPPORTED:\n      return 'FRAMEBUFFER_UNSUPPORTED';\n    default:\n      return `unknown error ${status}`;\n  }\n}\n\nfunction throwIfNull<T>(\n    gl: WebGLRenderingContext, returnTOrNull: () => T | null,\n    failureMessage: string): T {\n  const tOrNull: T|null = callAndCheck(gl, () => returnTOrNull());\n  if (tOrNull == null) {\n    throw new Error(failureMessage);\n  }\n  return tOrNull;\n}\n\nfunction validateTextureUnit(gl: WebGLRenderingContext, textureUnit: number) {\n  const maxTextureUnit = gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1;\n  const glTextureUnit = textureUnit + gl.TEXTURE0;\n  if (glTextureUnit < gl.TEXTURE0 || glTextureUnit > maxTextureUnit) {\n    const textureUnitRange = `[gl.TEXTURE0, gl.TEXTURE${maxTextureUnit}]`;\n    throw new Error(`textureUnit must be in ${textureUnitRange}.`);\n  }\n}\n\nexport function getBatchDim(shape: number[], dimsToSkip = 2): number {\n  return util.sizeFromShape(shape.slice(0, shape.length - dimsToSkip));\n}\n\nexport function getRowsCols(shape: number[]): [number, number] {\n  if (shape.length === 0) {\n    throw Error('Cannot get rows and columns of an empty shape array.');\n  }\n\n  return [\n    shape.length > 1 ? shape[shape.length - 2] : 1, shape[shape.length - 1]\n  ];\n}\n\nexport function getShapeAs3D(shape: number[]): [number, number, number] {\n  let shapeAs3D: [number, number, number] = [1, 1, 1];\n  const isScalar = shape.length === 0 || (shape.length === 1 && shape[0] === 1);\n  if (!isScalar) {\n    shapeAs3D =\n        [getBatchDim(shape), ...getRowsCols(shape)] as [number, number, number];\n  }\n  return shapeAs3D;\n}\n\nexport function getTextureShapeFromLogicalShape(\n    logShape: number[], isPacked = false): [number, number] {\n  let maxTexSize = env().getNumber('WEBGL_MAX_TEXTURE_SIZE');\n  let maxSizeForNarrowTex =\n      env().getNumber('WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE');\n  if (maxSizeForNarrowTex === Infinity &&\n      env().getBool('WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE')) {\n    maxSizeForNarrowTex = maxTexSize / 2;\n  }\n\n  if (isPacked) {\n    maxTexSize = maxTexSize * 2;\n    maxSizeForNarrowTex = maxSizeForNarrowTex * 2;\n\n    // This logic ensures we accurately count the number of packed texels needed\n    // to accommodate the tensor. We can only pack values in the same texel if\n    // they are from adjacent pairs of rows/cols within the same batch. So if a\n    // tensor has 3 rows, we pretend it has 4 rows in order to account for the\n    // fact that the texels containing the third row are half empty.\n    logShape = logShape.map(\n        (d, i) => i >= logShape.length - 2 ?\n            util.nearestLargerEven(logShape[i]) :\n            logShape[i]);\n\n    // Packed texture height is at least 2 (the channel height of a single\n    // texel).\n    if (logShape.length === 1) {\n      logShape = [2, logShape[0]];\n    }\n  }\n\n  // If logical shape is 2, we don't squeeze, since we want to match physical.\n  if (logShape.length !== 2) {\n    const squeezeResult = util.squeezeShape(logShape);\n    logShape = squeezeResult.newShape;\n  }\n\n  let size = util.sizeFromShape(logShape);\n  let textureShape: [number, number] = null;\n  if (logShape.length <= 1 && size <= maxTexSize) {\n    textureShape = [1, size];\n  } else if (\n      logShape.length === 2 && logShape[0] <= maxTexSize &&\n      logShape[1] <= maxTexSize) {\n    textureShape = logShape as [number, number];\n  } else if (\n      logShape.length === 3 && logShape[0] * logShape[1] <= maxTexSize &&\n      logShape[2] <= maxTexSize) {\n    textureShape = [logShape[0] * logShape[1], logShape[2]];\n  } else if (\n      logShape.length === 3 && logShape[0] <= maxTexSize &&\n      logShape[1] * logShape[2] <= maxTexSize) {\n    textureShape = [logShape[0], logShape[1] * logShape[2]];\n  } else if (\n      logShape.length === 4 &&\n      logShape[0] * logShape[1] * logShape[2] <= maxTexSize &&\n      logShape[3] <= maxTexSize) {\n    textureShape = [logShape[0] * logShape[1] * logShape[2], logShape[3]];\n  } else if (\n      logShape.length === 4 && logShape[0] <= maxTexSize &&\n      logShape[1] * logShape[2] * logShape[3] <= maxTexSize) {\n    textureShape = [logShape[0], logShape[1] * logShape[2] * logShape[3]];\n  }\n\n  // true if one edge length is 1 (1 or 2, if packed), while another edge\n  // length exceeds maxSizeForNarrowTex.\n  const isLongNarrowTex = textureShape != null &&\n      Math.max(...textureShape) > maxSizeForNarrowTex &&\n      Math.min(...textureShape) <= (isPacked ? 2 : 1) &&\n      Math.min(...textureShape) > 0;\n\n  if (textureShape == null || isLongNarrowTex) {\n    if (isPacked) {\n      // For packed textures size equals the number of channels required to\n      // accommodate the texture data. However in order to squarify such that\n      // inner dimensions stay even, we rewrite size to equal the number of\n      // texels. Then in the return statement we rehydrate the squarified\n      // dimensions to channel units.\n\n      const batchDim = getBatchDim(logShape);\n      let rows = 2, cols = 2;\n      if (logShape.length) {\n        [rows, cols] = getRowsCols(logShape);\n      }\n      size = batchDim * (rows / 2) * (cols / 2);\n      textureShape =\n          util.sizeToSquarishShape(size).map(d => d * 2) as [number, number];\n    } else {\n      textureShape = util.sizeToSquarishShape(size);\n    }\n  }\n\n  return textureShape;\n}\n\nfunction isEven(n: number): boolean {\n  return n % 2 === 0;\n}\n\n/**\n * This determines whether reshaping a packed texture requires rearranging\n * the data within the texture, assuming 2x2 packing.\n */\nexport function isReshapeFree(shape1: number[], shape2: number[]): boolean {\n  shape1 = shape1.slice(-2);\n  shape2 = shape2.slice(-2);\n\n  if (util.arraysEqual(shape1, shape2)) {\n    return true;\n  }\n\n  if (!shape1.length || !shape2.length) {  // One of the shapes is a scalar.\n    return true;\n  }\n\n  if (shape1[0] === 0 || shape1[1] === 0 || shape2[0] === 0 ||\n      shape2[1] === 0) {\n    return true;\n  }\n\n  if (shape1.length !== shape2.length) {  // One of the shapes is a vector.\n    const shape1Cols = shape1.slice(-1)[0];\n    const shape2Cols = shape2.slice(-1)[0];\n    if (shape1Cols === shape2Cols) {\n      return true;\n    }\n\n    if (isEven(shape1Cols) && isEven(shape2Cols) &&\n        (shape1[0] === 1 || shape2[0] === 1)) {\n      return true;\n    }\n  }\n  return shape1[1] === shape2[1] && isEven(shape1[0]) && isEven(shape2[0]);\n}\n\n// We cache webgl params because the environment gets reset between\n// unit tests and we don't want to constantly query the WebGLContext for\n// MAX_TEXTURE_SIZE.\nlet MAX_TEXTURE_SIZE: number;\nlet MAX_TEXTURES_IN_SHADER: number;\n\nexport function getWebGLMaxTextureSize(webGLVersion: number): number {\n  if (MAX_TEXTURE_SIZE == null) {\n    const gl = getWebGLContext(webGLVersion);\n    MAX_TEXTURE_SIZE = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n  }\n  return MAX_TEXTURE_SIZE;\n}\n\nexport function resetMaxTextureSize() {\n  MAX_TEXTURE_SIZE = null;\n}\nexport function resetMaxTexturesInShader() {\n  MAX_TEXTURES_IN_SHADER = null;\n}\n\nexport function getMaxTexturesInShader(webGLVersion: number): number {\n  if (MAX_TEXTURES_IN_SHADER == null) {\n    const gl = getWebGLContext(webGLVersion);\n    MAX_TEXTURES_IN_SHADER = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n  }\n  // We cap at 16 to avoid spurious runtime \"memory exhausted\" error.\n  return Math.min(16, MAX_TEXTURES_IN_SHADER);\n}\n\nexport function getWebGLDisjointQueryTimerVersion(webGLVersion: number):\n    number {\n  if (webGLVersion === 0) {\n    return 0;\n  }\n\n  let queryTimerVersion: number;\n  const gl = getWebGLContext(webGLVersion);\n\n  if (hasExtension(gl, 'EXT_disjoint_timer_query_webgl2') &&\n      webGLVersion === 2) {\n    queryTimerVersion = 2;\n  } else if (hasExtension(gl, 'EXT_disjoint_timer_query')) {\n    queryTimerVersion = 1;\n  } else {\n    queryTimerVersion = 0;\n  }\n  return queryTimerVersion;\n}\n\nexport function hasExtension(gl: WebGLRenderingContext, extensionName: string) {\n  const ext = gl.getExtension(extensionName);\n  return ext != null;\n}\n\nexport function isWebGLVersionEnabled(webGLVersion: 1|2) {\n  try {\n    const gl = getWebGLContext(webGLVersion);\n    if (gl != null) {\n      return true;\n    }\n  } catch (e) {\n    console.log('Error when getting WebGL context: ', e);\n    return false;\n  }\n  return false;\n}\n\nexport function isCapableOfRenderingToFloatTexture(webGLVersion: number):\n    boolean {\n  if (webGLVersion === 0) {\n    return false;\n  }\n\n  const gl = getWebGLContext(webGLVersion);\n\n  if (webGLVersion === 1) {\n    if (!hasExtension(gl, 'OES_texture_float')) {\n      return false;\n    }\n  } else {\n    if (!hasExtension(gl, 'EXT_color_buffer_float')) {\n      return false;\n    }\n  }\n\n  const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);\n  return isFrameBufferComplete;\n}\n\n/**\n * Check if we can download values from a float/half-float texture.\n *\n * Note that for performance reasons we use binding a texture to a framebuffer\n * as a proxy for ability to download float values later using readPixels. The\n * texture params of this texture will not match those in readPixels exactly\n * but if we are unable to bind some kind of float texture to the frameBuffer\n * then we definitely will not be able to read float values from it.\n */\nexport function isDownloadFloatTextureEnabled(webGLVersion: number): boolean {\n  if (webGLVersion === 0) {\n    return false;\n  }\n\n  const gl = getWebGLContext(webGLVersion);\n\n  if (webGLVersion === 1) {\n    if (!hasExtension(gl, 'OES_texture_float')) {\n      return false;\n    }\n    if (!hasExtension(gl, 'WEBGL_color_buffer_float')) {\n      return false;\n    }\n  } else {\n    if (hasExtension(gl, 'EXT_color_buffer_float')) {\n      return createFloatTextureAndBindToFramebuffer(gl);\n    }\n\n    const COLOR_BUFFER_HALF_FLOAT = 'EXT_color_buffer_half_float';\n    if (hasExtension(gl, COLOR_BUFFER_HALF_FLOAT)) {\n      const textureHalfFloatExtension =\n          gl.getExtension(COLOR_BUFFER_HALF_FLOAT);\n      return createHalfFloatTextureAndBindToFramebuffer(\n          gl, textureHalfFloatExtension);\n    }\n\n    return false;\n  }\n\n  const isFrameBufferComplete = createFloatTextureAndBindToFramebuffer(gl);\n  return isFrameBufferComplete;\n}\n\nfunction createFloatTextureAndBindToFramebuffer(gl: WebGLRenderingContext):\n    boolean {\n  const texConfig = getTextureConfig(gl);\n\n  const texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n\n  const width = 1;\n  const height = 1;\n  gl.texImage2D(\n      gl.TEXTURE_2D, 0, texConfig.internalFormatFloat, width, height, 0,\n      texConfig.textureFormatFloat, texConfig.textureTypeFloat, null);\n\n  const frameBuffer = gl.createFramebuffer();\n  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n  gl.framebufferTexture2D(\n      gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n\n  const isFrameBufferComplete =\n      gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;\n\n  gl.bindTexture(gl.TEXTURE_2D, null);\n  gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n  gl.deleteTexture(texture);\n  gl.deleteFramebuffer(frameBuffer);\n\n  return isFrameBufferComplete;\n}\n\nfunction createHalfFloatTextureAndBindToFramebuffer(\n    // tslint:disable-next-line:no-any\n    gl: WebGLRenderingContext, textureHalfFloatExtension: any): boolean {\n  const texConfig = getTextureConfig(gl, textureHalfFloatExtension);\n  const texture = gl.createTexture();\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n\n  const width = 1;\n  const height = 1;\n  gl.texImage2D(\n      gl.TEXTURE_2D, 0, texConfig.internalFormatHalfFloat, width, height, 0,\n      texConfig.textureFormatFloat, texConfig.textureTypeHalfFloat, null);\n\n  const frameBuffer = gl.createFramebuffer();\n  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n  gl.framebufferTexture2D(\n      gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n\n  const isFrameBufferComplete =\n      gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE;\n\n  gl.bindTexture(gl.TEXTURE_2D, null);\n  gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n  gl.deleteTexture(texture);\n  gl.deleteFramebuffer(frameBuffer);\n\n  return isFrameBufferComplete;\n}\n\nexport function isWebGLFenceEnabled(webGLVersion: number) {\n  if (webGLVersion !== 2) {\n    return false;\n  }\n  const gl = getWebGLContext(webGLVersion);\n\n  // tslint:disable-next-line:no-any\n  const isEnabled = (gl as any).fenceSync != null;\n  return isEnabled;\n}\n\nexport function assertNotComplex(\n    tensor: TensorInfo|TensorInfo[], opName: string): void {\n  if (!Array.isArray(tensor)) {\n    tensor = [tensor];\n  }\n  tensor.forEach(t => {\n    if (t != null) {\n      util.assert(\n          t.dtype !== 'complex64',\n          () => `${opName} does not support complex64 tensors ` +\n              'in the WebGL backend.');\n    }\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}